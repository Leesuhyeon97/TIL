#  객체 지향 프로그래밍의 특징

## Encapsulation (캡슐화)

> 데이터 보호장치
>
> private 데이터를 public 메소드를 이용해 핸들링(Setter/Getter)

```java
public class Member { //java bean
	private int age;
	private String name;
	
	public void setName(String newName) {
		if(newName == null) {
			System.out.println("이름을 정확히 입력해주세요");
		}
		else {
			name = newName;
		}
	}
	public void setAge(int newAge) { // setter
		// 유효성 검사
		if(newAge > 0) {
			age = newAge;
		}
		else {
			System.out.println("나이는 0보다 커야합니다.");
		}
	}
	public int getAge() { //getter
		return age;
	}
	public String getName() {
		return name;
	}
}
```

```java
public class Test {

	public static void main(String[] args) {
		Member m = new Member();
		m.setName("홍길동");
		m.setAge(25);
		System.out.println(m.getName());
		System.out.println(m.getAge());
	}

}

```

private < default < protect < public

<위치> class  , <위치> dataType 이름 (=값) , <위치> 리턴타입 이름 ( [ ] ){ }

modifier(지정자)

접근지정자 / 사용지정자 (abstract, static, final)

## Inheritance (상속)

> `Super` member를 물려받는 것 (extends `Super`-단일상속)
>
> 상속이 많아지면 뿌리가 되는 데이터,메소드를 찾기 모호해지기 때문에 단일 상속을 함

* 상속의 관계를 잘 설정해야함 Person -> Member ->(VipMember/BlackListMember)

```java
package test2.inheritance;

public class Person {
	private int age;
	private String name;
	
	public void setName(String newName) {
		if(newName == null) {
			System.out.println("이름을 정확히 입력해주세요");
		}
		else {
			name = newName;
		}
	}
	public void setAge(int newAge) { // setter
		// 유효성 검사
		if(newAge > 0) {
			age = newAge;
		}
		else {
			System.out.println("나이는 0보다 커야합니다.");
		}
	}
	public int getAge() { //getter
		return age;
	}
	public String getName() {
		return name;
	}

```

```java
package test1.encapsulation;

import test2.inheritance.Person; //import 받아서 사용하겠다

public class Member extends Person{
}
```

다른 패키지의 Person을 받아서 사용하겠다는 의미입니다.

```java
package test2.inheritance;

import test1.encapsulation.Member; //import 받아서 사용하겠다

public class VipMember extends Member {
    private int point = 1000;
    	public int getPoint() {
		return point;
	}

	public void setPoint(int point) {
        //유효성 검사
		if(point>1000) {
		this.point = point;
		}
		else {
			System.out.println("1000보다만 큰 값만 입력되어야 합니다.");
		}
	}
}
```

마찬가지로 다른패키지의 Member를 받아서 사용하겠다는 의미입니다.

```java
package test1.encapsulation;

import test2.inheritance.VipMember; //import 받아서 사용하겠다

public class Test {

	public static void main(String[] args) {
		Member m = new Member();
		m.setName("홍길동");
		m.setAge(25);
		System.out.println(m.getName());
		System.out.println(m.getAge());
		
		
		VipMember vm = new VipMember();
		vm.setPoint(0);
		System.out.println(vm.getPoint());
	}
}
```

상단 source -> generate setter and getter -> point 체크 -> 실행

자동적으로 setter & getter 코딩

* 유효성 검사 (If / else)를 넣어서 좋은 코드를 만들어야 합니다.

public 과 private를 잘 구분해서 사용해야 합니다.

## Polymorphism 다형성

### 다형적 변수 

* 슈퍼 타입으로 선언된 변수는 모든 자식 객체를 가리킬 수 있음

### 오버라이딩

* Shadow effect를 없애기 위한 방법 ==성능과 확장성을 향상 시키기 위해서
  * 슈퍼의 메소드를 서브에서 재정의

```java
package test3.polymorphism;

public class Triangle extends Shape {
	int width = 5, height =6;
	
	public void area() {
		System.out.println("삼각형의 넓이 : " + (width * height/2));
	}
}	
```

```java
package test3.polymorphism;

public class Rectangle extends Shape {
	int width = 5, height =6;
	
	public void area() {
		System.out.println("사각형의 넓이 : " + (width * height));
	}
}
```

```java
package test3.polymorphism;

public class Circle extends Shape {
	int radius = 4;
	
	public void area() {
		System.out.println("원의 넓이 :" + (3.14 * radius * radius));
	}
}
```

```java
package test3.polymorphism;

public class Printer {
	public void print(Shape s) { // Object o 는 슈퍼타입 원하는 도형을 제외하고도 전부 다 받기 때문에 서브 메소드를 따로 만들어서 원하는 값만 받게 만듦.
		/*절차 중심적 = if else 는 성능이 떨어짐
		type checking, type casting은 성능이 떨어짐
		
		if(s instanceof Circle) {   -type checking
			Circle c = (Circle)s;   -type casting
			c.areaCircle();  
		}
		else if (s instanceof Rectangle) {
			Rectangle r = (Rectangle)s;
			r.areaRec();
		}
		else if (s instanceof Triangle) {
			Triangle t = (Triangle)s;
			t.areaTri();
		}*/
		
		//***** 객체 지향적 - 성능과 확장성을 다 잡음
		s.area();
	}
}
```

```java
package test3.polymorphism;

public class Shape {
	public void area() { 
		//본래는 데이터, 메소드가 없는 클래스였지만,
		//타입 문제를 해결하기위해 뒤늦게 메소드 추가
	}
}
```

--위의 코드가 슈퍼의 메소드를 서브에서 재정의한 것

```java
package test3.polymorphism;

public class Test {

	public static void main(String[] args) {
		Circle c = new Circle();
		Rectangle r = new Rectangle();
		Triangle t = new Triangle();

		Printer out = new Printer();
		out.print(c);
		out.print(r);
		out.print(t);
	}
}
```

### 오버로딩

> 한 클래스내에 같은 이름의 메소드가 다수 존재 하는 것
>
> 메소드 이름은 같되,  args내용은 달라야함 !!!

```java
package test6.constructor;

public class Member {
	private String name, adress, phone;
	private int age;
	
	public Member() {
		super(); // 모든 생성자는 자동으로 super가 생성됨, 명시적으로 표현하면 무조건 첫                     번째 줄에 적어야함 다른 줄에 넣으면 에러발생
	}
	
	public Member (String name,String address,String phone,int age) {
		super();
		setName(name);
		setPhone(phone);
		setAdress(address);
		setAge(age);
	}
	// Set method는 유효성 검사를 해야함 !!!!!!!!!
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAdress() {
		return adress;
	}
	public void setAdress(String adress) {
		this.adress = adress;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
```

```java
package test6.constructor;

public class Test {
	
	public static void main(String [] args) {
		Member m1 = new Member("홍길동","010-1111-1111","경산",25);
		
		Member m2 = new Member("카지노","010-2222-2222","서울",22);

		Member m3 = new Member();
	}
}
```

